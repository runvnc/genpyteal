#!/usr/bin/env python3
import json
from redbaron import RedBaron
import traceback
import sys
from collections.abc import Iterable

def iterable(obj):
    return isinstance(obj, Iterable)
    
def catchdump(x):
  try:    
    return x.dumps()      
  except:
    pass  

def hasMultiStmt(node):
  l =[]
  try:
    for nd in node:
      nodes = nd.find_all(['ifelseblock','atomtrailers', 'return'], recursive=False)
      nodes = nodes.filter(lambda x: x != None)
      l.extend(nodes)
    return len(l) > 1
  except:
    pass

def getScratch(red):
  s = red.find_all('assign')
  if isinstance(s, list):
    s = s.filter(lambda x: 'ScratchVar' in x)
  if s:
    return '\n'.join(s.map(lambda x: x.dumps()))
  else:
    return ''

def hasScratch(red, varname):
  if varname == 'result':
    found = True
  parentdef = red.parent_find('def')
  s = parentdef.find_all('assign')
  match = f"{varname} = ScratchVar"
  if match in s.dumps():
    return True
  else:
    return False

def findmap(red, which, how):
  l = red.find_all(which)
  l.map(how)

def all(red):
  try:
    if hasattr(red,'type'):
      if red.type == 'def' and red.name != 'teal':
        if len(red.decorators) == 0:
          if 'return' in red.dumps():
            red.decorators.append("@Subroutine(uint64)")
          else:
            red.decorators.append("@Subroutine(TealType.none)")
      findmap(red, 'assign', assigns)
      findmap(red, 'boolean_operator', bools)
      findmap(red, 'int', ints)
      findmap(red, 'string', strings)
      findmap(red, 'ifelseblock', ifs)
      findmap(red, 'call', calls)
      findmap(red, 'name', names)
    strs_ = []
    hasMulti = hasMultiStmt(red)
    scratch = getScratch(red)
    if hasattr(red,'type') and red.type == 'name':
      return
    try:
      for nd in red:
        nodes = nd.find_all(['ifelseblock','atomtrailers', 'return'], recursive=False)
        if hasMulti:
          findmap(nodes, 'return', returns)
          
        strs = nodes.map(catchdump)
        strs = strs.filter(lambda x: x != None)
        strs_.extend(strs)
    except:
      pass
    if len(strs_) > 1:
      strlist = ',\n'.join(strs_)
      red.value = f"{scratch}\nreturn Seq([\n{strlist}])\n"    
  except BaseException as err:
    sys.stderr.write(f"Unexpected {err=}, {type(err)=}")  
    sys.stderr.write(traceback.format_exc())
    pass  

def bools(boolOp):
  all(boolOp.first)
  all(boolOp.second)
  boolOp.parent.value = f"{boolOp.value.title()}({boolOp.first}, {boolOp.second})"

def assigns(asn):  
  if 'ScratchVar' in asn.value.dumps():
    return
  if hasattr(asn, 'asnChecked'):
    print('checked already, ', asn.dumps())
    return
  else:
    print('not checked already', asn.dumps())
  parval = asn.value
  asn.asnChecked = True
  if hasattr(parval, 'filtered'):
    parval = parval.filtered()[0]
  safetycond = 'safety_cond' in asn.dumps()
  if safetycond:
    print(1)
  if hasattr(parval, 'type'):  
    if safetycond:
      print(2)
    if parval.type == 'boolean' or parval.type == 'comparison' or parval.type in 'boolean_operator':
      return
    else:
      if safetycond:
        print(' | | | Parval type not bool or compare')
        print(parval.type)
        print(parval.help())
  else:
    print(' > > > Parent value does not have type attr: asn.value=',asn.value.dumps())
    print(parval.help())    
    print(' ')
  makescratch = ''
  is_str = "'" in asn.value.dumps() or '"' in asn.value.dumps()
  if not hasScratch(asn, asn.target.value):
    if is_str:
      typ = 'TealType.bytes'
    else:
      typ = 'TealType.uint64'
    makescratch = f"{asn.target.value} = ScratchVar({typ})\n"
    asn.insert_before(makescratch)
  asn.replace(f"{asn.target.value}.store({asn.value.dumps()})")

def calls(nd):
  #all(nd.value)
  try:
    if nd.type != 'call':
      return
    if nd.parent[0].value in ['Begin','SetField','SetFields','Submit']:          
      nd.parent[0].replace(f"InnerTxnBuilder.{nd.parent[0].dumps()}")
  except:
    pass

def names(nd):
  if nd.parent.type == 'assignment' and nd.parent.target == nd:
    return
  if nd.dumps()+'.load()' in nd.parent.dumps():
    return
  if nd.dumps()+'.store(' in nd.parent.dumps():
    return

  varname = nd.dumps()

  try:
    if hasScratch(nd, varname):
      nd.replace(f"{nd.dumps()}.load()")
  except:
    pass
  
def ifs(if_):
  all(if_.value)
  if_.value = f"If({if_.value[0].test.dumps()}, {if_.value[0].value.dumps()})\n\n"

def returns(ret):
  all(ret.value)
  ret.replace(f"Return({ret.value.dumps().replace('return ','')})")

def ints(i):
  try:
    if i.parent.type == 'def_argument':
      return
    if i.parent.parent.parent.value[0].value == 'Int':
      return
  except:
    pass
  i.replace(f"Int({i.value})")

def strings(i):
  try:
    if i.parent.type == 'def_argument':
      return
    if i.parent.parent.parent.value[0].value == 'Bytes':
      return
  except:
    pass
  i.replace(f"Bytes({i.dumps()})")

progroot = 0

def convert(fname, mode):
  source = open(fname, "r")
  red = RedBaron(source.read())
  progroot = red
  findmap(red, 'def', all)  
  print("from pyteal import *\n")
  print("globals().update(TealType.__members__)")

  print(red.dumps())
  print(f"if __name__ == \"__main__\":\n    print(compileTeal(teal(), mode=Mode.{mode}, version=5))")

mode = 'Application'

if len(sys.argv) > 2:
  if sys.argv[2] == 'sig':
    mode = 'Signature'
convert(sys.argv[1], mode)

